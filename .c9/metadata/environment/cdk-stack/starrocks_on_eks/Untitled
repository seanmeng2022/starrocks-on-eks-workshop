{"changed":true,"filter":false,"title":"Untitled","tooltip":"/cdk-stack/starrocks_on_eks/Untitled","value":"import boto3\nfrom aws_cdk import (\n    Stack,\n    RemovalPolicy,\n    aws_ec2 as ec2,\n    aws_rds as rds,\n    aws_s3 as s3,\n    aws_eks as eks,\n    CfnOutput,\n    SecretValue,\n    lambda_layer_kubectl_v31,\n    Tags,\n    aws_iam as iam,\n    aws_ecr as ecr,\n    Fn\n)\n\nfrom constructs import Construct\nimport os\n\nclass StarrocksOnEksStack(Stack):\n\n    def __init__(self, scope: Construct, construct_id: str, **kwargs) -> None:\n        super().__init__(scope, construct_id, **kwargs)\n\n        # Get EC2 instance details using boto3\n        ec2_client = boto3.client('ec2')\n        \n        # Find EC2 instances with name starting with aws-cloud9\n        instances = ec2_client.describe_instances(\n            Filters=[\n                {\n                    'Name': 'tag:Name',\n                    'Values': ['aws-cloud9*']\n                },\n                {\n                    'Name': 'instance-state-name',\n                    'Values': ['running']\n                }\n            ]\n        )\n        \n        if not instances['Reservations'] or not instances['Reservations'][0]['Instances']:\n            raise Exception(\"Could not find any running EC2 instance with name starting with aws-cloud9\")\n            \n        instance_details = instances['Reservations'][0]['Instances'][0]\n        vpc_id = instance_details['VpcId']\n        private_ip = instance_details['PrivateIpAddress']\n        public_ip = instance_details['PublicIpAddress']\n\n        # Use the found VPC and apply tags to its subnets\n        vpc = ec2.Vpc.from_lookup(self, \"ExistingVPC\",\n            vpc_id=vpc_id\n        )\n\n        # Get all subnets in the VPC using boto3\n        subnets = ec2_client.describe_subnets(\n            Filters=[{'Name': 'vpc-id', 'Values': [vpc_id]}]\n        )['Subnets']\n\n        # Tag private and public subnets\n        for subnet in subnets:\n            # Check if subnet is private (no route to internet gateway)\n            routes = ec2_client.describe_route_tables(\n                Filters=[{'Name': 'association.subnet-id', 'Values': [subnet['SubnetId']]}]\n            )['RouteTables']\n            \n            is_private = True\n            if routes:\n                for route in routes[0]['Routes']:\n                    if route.get('GatewayId', '').startswith('igw-'):\n                        is_private = False\n                        break\n\n            # Apply appropriate tags based on subnet type\n            if is_private:\n                ec2_client.create_tags(\n                    Resources=[subnet['SubnetId']],\n                    Tags=[{'Key': 'kubernetes.io/role/internal-elb', 'Value': '1'}]\n                )\n            else:\n                ec2_client.create_tags(\n                    Resources=[subnet['SubnetId']],\n                    Tags=[{'Key': 'kubernetes.io/role/elb', 'Value': '1'}]\n                )\n\n        # Create security group for StarRocks ports\n        starrocks_ports_sg = ec2.SecurityGroup(self, \"StarRocksPortsSecurityGroup\",\n            vpc=vpc,\n            description=\"Security group for StarRocks ports access\",\n            allow_all_outbound=True\n        )\n\n        # Allow inbound access on ports 8030 and 9030 only from Cloud9 instance's public IP\n        starrocks_ports_sg.add_ingress_rule(\n            ec2.Peer.ipv4(public_ip + '/32'),\n            ec2.Port.tcp(8030),\n            \"Allow port 8030 access from Cloud9 public IP\"\n        )\n        starrocks_ports_sg.add_ingress_rule(\n            ec2.Peer.ipv4(public_ip + '/32'),\n            ec2.Port.tcp(9030),\n            \"Allow port 9030 access from Cloud9 public IP\"\n        )\n\n        # Create security group for EKS control plane\n        eks_security_group = ec2.SecurityGroup(self, \"EKSControlPlaneSecurityGroup\",\n            vpc=vpc,\n            description=\"Security group for EKS cluster control plane\",\n            allow_all_outbound=True\n        )\n\n        # Allow all inbound traffic\n        eks_security_group.add_ingress_rule(\n            ec2.Peer.any_ipv4(),\n            ec2.Port.all_traffic(),\n            \"Allow all inbound traffic\"\n        )\n\n        # Create EKS mater role\n        masters_role = iam.Role(self, \"EksMastersRole\",\n            assumed_by=iam.AccountRootPrincipal()  \n        )\n\n\n        # Create EKS Cluster\n        eks_cluster = eks.Cluster(self, \"StarrocksEKSCluster\",\n            version=eks.KubernetesVersion.V1_31,\n            vpc=vpc,\n            vpc_subnets=[ec2.SubnetSelection(subnet_type=ec2.SubnetType.PRIVATE_WITH_EGRESS)],\n            default_capacity=0,  # We will add a managed node group separately\n            kubectl_layer=lambda_layer_kubectl_v31.KubectlV31Layer(self, \"kubectl\"),\n            security_group=eks_security_group,\n            masters_role=masters_role\n        )\n\n\n        # Add managed node group\n        eks_cluster.add_nodegroup_capacity(\"StarrocksNodeGroup\",\n            instance_types=[ec2.InstanceType(\"c6i.8xlarge\")],\n            min_size=3,\n            max_size=3,\n            desired_size=3,\n            subnets=ec2.SubnetSelection(subnet_type=ec2.SubnetType.PRIVATE_WITH_EGRESS)\n        )\n\n        # Create Parameter Group for binlog settings\n        parameter_group = rds.ParameterGroup(self, \"AuroraParameterGroup\",\n            engine=rds.DatabaseClusterEngine.aurora_mysql(\n                version=rds.AuroraMysqlEngineVersion.VER_3_05_2\n            ),\n            parameters={\n                \"binlog_format\": \"ROW\",\n                \"binlog_row_image\": \"FULL\",\n                \"binlog_checksum\": \"NONE\"\n            }\n        )\n\n\n        # Create security group for Aurora\n        aurora_security_group = ec2.SecurityGroup(self, \"AuroraSecurityGroup\",\n            vpc=vpc,\n            description=\"Security group for Aurora cluster\"\n        )\n\n        # Allow inbound MySQL traffic only from Cloud9 instance\n        aurora_security_group.add_ingress_rule(\n            ec2.Peer.ipv4(private_ip + '/32'),\n            ec2.Port.tcp(3306),\n            \"Allow MySQL access from Cloud9\"\n        )\n\n\n        # Create Aurora Serverless v2 Cluster with removal policy\n        cluster = rds.DatabaseCluster(self, \"AuroraCluster\",\n            # removal_policy=RemovalPolicy.RETAIN,  # Prevent cluster deletion on stack updates\n            security_groups=[aurora_security_group],\n            credentials=rds.Credentials.from_password(\n                username=\"admin\",\n                password=SecretValue.unsafe_plain_text(\"starrocks\")\n            ),\n            engine=rds.DatabaseClusterEngine.aurora_mysql(\n                version=rds.AuroraMysqlEngineVersion.VER_3_05_2\n            ),\n            vpc=vpc,\n            parameter_group=parameter_group,\n            serverless_v2_min_capacity=0.5,\n            serverless_v2_max_capacity=4,\n            writer=rds.ClusterInstance.serverless_v2(\"writer\"),\n            readers=[\n                rds.ClusterInstance.serverless_v2(\"reader1\", scale_with_writer=True)\n            ]\n        )\n\n        # Output the cluster endpoint\n        CfnOutput(self, \"ClusterEndpoint\",\n            value=cluster.cluster_endpoint.hostname\n        )\n        \n        # Output the reader endpoint\n        CfnOutput(self, \"ReaderEndpoint\",\n            value=cluster.cluster_read_endpoint.hostname\n        )\n        \n        # Create S3 bucket with consistent name and retention policy\n        bucket = s3.Bucket(self, \"WorkshopBucket\",\n            bucket_name=f\"starrocks-on-eks-workshop-{self.account}-{self.region}\",\n            # removal_policy=RemovalPolicy.RETAIN,  # Prevent bucket deletion on stack updates\n            auto_delete_objects=False\n        )\n        \n        # Output the bucket name\n        CfnOutput(self, \"BucketName\",\n            value=bucket.bucket_name\n        )\n\n        # Output the EKS cluster name\n        CfnOutput(self, \"EKSClusterName\",\n            value=eks_cluster.cluster_name\n        )\n        \n        # Create ECR repository for Flink CDC\n        ecr_repository = ecr.Repository(self, \"FlinkCdcRepository\",\n            repository_name=\"flink-cdc-pipeline\",\n            # removal_policy=RemovalPolicy.RETAIN,  # Prevent repository deletion on stack updates\n            image_scan_on_push=True  # Enable vulnerability scanning\n        )\n        \n        # Output the ECR repository URI\n        CfnOutput(self, \"FlinkCdcRepositoryUri\",\n            value=ecr_repository.repository_uri\n        )\n","undoManager":{"mark":-2,"position":0,"stack":[[{"start":{"row":0,"column":0},"end":{"row":232,"column":0},"action":"insert","lines":["import boto3","from aws_cdk import (","    Stack,","    RemovalPolicy,","    aws_ec2 as ec2,","    aws_rds as rds,","    aws_s3 as s3,","    aws_eks as eks,","    CfnOutput,","    SecretValue,","    lambda_layer_kubectl_v31,","    Tags,","    aws_iam as iam,","    aws_ecr as ecr,","    Fn",")","","from constructs import Construct","import os","","class StarrocksOnEksStack(Stack):","","    def __init__(self, scope: Construct, construct_id: str, **kwargs) -> None:","        super().__init__(scope, construct_id, **kwargs)","","        # Get EC2 instance details using boto3","        ec2_client = boto3.client('ec2')","        ","        # Find EC2 instances with name starting with aws-cloud9","        instances = ec2_client.describe_instances(","            Filters=[","                {","                    'Name': 'tag:Name',","                    'Values': ['aws-cloud9*']","                },","                {","                    'Name': 'instance-state-name',","                    'Values': ['running']","                }","            ]","        )","        ","        if not instances['Reservations'] or not instances['Reservations'][0]['Instances']:","            raise Exception(\"Could not find any running EC2 instance with name starting with aws-cloud9\")","            ","        instance_details = instances['Reservations'][0]['Instances'][0]","        vpc_id = instance_details['VpcId']","        private_ip = instance_details['PrivateIpAddress']","        public_ip = instance_details['PublicIpAddress']","","        # Use the found VPC and apply tags to its subnets","        vpc = ec2.Vpc.from_lookup(self, \"ExistingVPC\",","            vpc_id=vpc_id","        )","","        # Get all subnets in the VPC using boto3","        subnets = ec2_client.describe_subnets(","            Filters=[{'Name': 'vpc-id', 'Values': [vpc_id]}]","        )['Subnets']","","        # Tag private and public subnets","        for subnet in subnets:","            # Check if subnet is private (no route to internet gateway)","            routes = ec2_client.describe_route_tables(","                Filters=[{'Name': 'association.subnet-id', 'Values': [subnet['SubnetId']]}]","            )['RouteTables']","            ","            is_private = True","            if routes:","                for route in routes[0]['Routes']:","                    if route.get('GatewayId', '').startswith('igw-'):","                        is_private = False","                        break","","            # Apply appropriate tags based on subnet type","            if is_private:","                ec2_client.create_tags(","                    Resources=[subnet['SubnetId']],","                    Tags=[{'Key': 'kubernetes.io/role/internal-elb', 'Value': '1'}]","                )","            else:","                ec2_client.create_tags(","                    Resources=[subnet['SubnetId']],","                    Tags=[{'Key': 'kubernetes.io/role/elb', 'Value': '1'}]","                )","","        # Create security group for StarRocks ports","        starrocks_ports_sg = ec2.SecurityGroup(self, \"StarRocksPortsSecurityGroup\",","            vpc=vpc,","            description=\"Security group for StarRocks ports access\",","            allow_all_outbound=True","        )","","        # Allow inbound access on ports 8030 and 9030 only from Cloud9 instance's public IP","        starrocks_ports_sg.add_ingress_rule(","            ec2.Peer.ipv4(public_ip + '/32'),","            ec2.Port.tcp(8030),","            \"Allow port 8030 access from Cloud9 public IP\"","        )","        starrocks_ports_sg.add_ingress_rule(","            ec2.Peer.ipv4(public_ip + '/32'),","            ec2.Port.tcp(9030),","            \"Allow port 9030 access from Cloud9 public IP\"","        )","","        # Create security group for EKS control plane","        eks_security_group = ec2.SecurityGroup(self, \"EKSControlPlaneSecurityGroup\",","            vpc=vpc,","            description=\"Security group for EKS cluster control plane\",","            allow_all_outbound=True","        )","","        # Allow all inbound traffic","        eks_security_group.add_ingress_rule(","            ec2.Peer.any_ipv4(),","            ec2.Port.all_traffic(),","            \"Allow all inbound traffic\"","        )","","        # Create EKS mater role","        masters_role = iam.Role(self, \"EksMastersRole\",","            assumed_by=iam.AccountRootPrincipal()  ","        )","","","        # Create EKS Cluster","        eks_cluster = eks.Cluster(self, \"StarrocksEKSCluster\",","            version=eks.KubernetesVersion.V1_31,","            vpc=vpc,","            vpc_subnets=[ec2.SubnetSelection(subnet_type=ec2.SubnetType.PRIVATE_WITH_EGRESS)],","            default_capacity=0,  # We will add a managed node group separately","            kubectl_layer=lambda_layer_kubectl_v31.KubectlV31Layer(self, \"kubectl\"),","            security_group=eks_security_group,","            masters_role=masters_role","        )","","","        # Add managed node group","        eks_cluster.add_nodegroup_capacity(\"StarrocksNodeGroup\",","            instance_types=[ec2.InstanceType(\"c6i.8xlarge\")],","            min_size=3,","            max_size=3,","            desired_size=3,","            subnets=ec2.SubnetSelection(subnet_type=ec2.SubnetType.PRIVATE_WITH_EGRESS)","        )","","        # Create Parameter Group for binlog settings","        parameter_group = rds.ParameterGroup(self, \"AuroraParameterGroup\",","            engine=rds.DatabaseClusterEngine.aurora_mysql(","                version=rds.AuroraMysqlEngineVersion.VER_3_05_2","            ),","            parameters={","                \"binlog_format\": \"ROW\",","                \"binlog_row_image\": \"FULL\",","                \"binlog_checksum\": \"NONE\"","            }","        )","","","        # Create security group for Aurora","        aurora_security_group = ec2.SecurityGroup(self, \"AuroraSecurityGroup\",","            vpc=vpc,","            description=\"Security group for Aurora cluster\"","        )","","        # Allow inbound MySQL traffic only from Cloud9 instance","        aurora_security_group.add_ingress_rule(","            ec2.Peer.ipv4(private_ip + '/32'),","            ec2.Port.tcp(3306),","            \"Allow MySQL access from Cloud9\"","        )","","","        # Create Aurora Serverless v2 Cluster with removal policy","        cluster = rds.DatabaseCluster(self, \"AuroraCluster\",","            # removal_policy=RemovalPolicy.RETAIN,  # Prevent cluster deletion on stack updates","            security_groups=[aurora_security_group],","            credentials=rds.Credentials.from_password(","                username=\"admin\",","                password=SecretValue.unsafe_plain_text(\"starrocks\")","            ),","            engine=rds.DatabaseClusterEngine.aurora_mysql(","                version=rds.AuroraMysqlEngineVersion.VER_3_05_2","            ),","            vpc=vpc,","            parameter_group=parameter_group,","            serverless_v2_min_capacity=0.5,","            serverless_v2_max_capacity=4,","            writer=rds.ClusterInstance.serverless_v2(\"writer\"),","            readers=[","                rds.ClusterInstance.serverless_v2(\"reader1\", scale_with_writer=True)","            ]","        )","","        # Output the cluster endpoint","        CfnOutput(self, \"ClusterEndpoint\",","            value=cluster.cluster_endpoint.hostname","        )","        ","        # Output the reader endpoint","        CfnOutput(self, \"ReaderEndpoint\",","            value=cluster.cluster_read_endpoint.hostname","        )","        ","        # Create S3 bucket with consistent name and retention policy","        bucket = s3.Bucket(self, \"WorkshopBucket\",","            bucket_name=f\"starrocks-on-eks-workshop-{self.account}-{self.region}\",","            # removal_policy=RemovalPolicy.RETAIN,  # Prevent bucket deletion on stack updates","            auto_delete_objects=False","        )","        ","        # Output the bucket name","        CfnOutput(self, \"BucketName\",","            value=bucket.bucket_name","        )","","        # Output the EKS cluster name","        CfnOutput(self, \"EKSClusterName\",","            value=eks_cluster.cluster_name","        )","        ","        # Create ECR repository for Flink CDC","        ecr_repository = ecr.Repository(self, \"FlinkCdcRepository\",","            repository_name=\"flink-cdc-pipeline\",","            # removal_policy=RemovalPolicy.RETAIN,  # Prevent repository deletion on stack updates","            image_scan_on_push=True  # Enable vulnerability scanning","        )","        ","        # Output the ECR repository URI","        CfnOutput(self, \"FlinkCdcRepositoryUri\",","            value=ecr_repository.repository_uri","        )",""],"id":1}]]},"ace":{"folds":[],"scrolltop":0,"scrollleft":0,"selection":{"start":{"row":213,"column":36},"end":{"row":213,"column":36},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":0},"timestamp":1739517906763}